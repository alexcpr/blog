<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" /><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Cesser d’utiliser XMLHttpRequest et passer à fetch | Xela’s Blog</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Cesser d’utiliser XMLHttpRequest et passer à fetch" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="L’API XHR la plus populaire est XMLHttpRequest qui n’a pas vraiment été faite pour ce pour quoi nous l’utilisons. C’est pourquoi l’API fetch a été créée, l’API fetch est en quelque sorte un remplacement moderne pour XMLHttpRequest. Jetons un coup d’oeil à cette méthode window.fetch. Compatibilité des navigateurs Une chose importante lors du développement d’une application web est la compatibilité du navigateur avec les technologies utilisées. Comme XMLHttpRequest est plus ancien, il a logiquement une meilleure compatibilité avec les navigateurs plus anciens par rapport à fetch, cependant, il y a des polyfill’s bien faits qui rendent cette API moderne compatible avec les navigateurs plus anciens tels que IE, etc… (c.f Compatibilité XMLHttpRequesty, Compatibilité Fetch) Utilisation de base de XMLHttpRequest XHR est un peu trop compliqué à mon avis et je ne comprends toujours pas pourquoi XML est en majuscules alors que Http est en camel-case, cela n’a aucun sens. Quoi qu’il en soit, voici un usage courant de l’API XHR if (window.XMLHttpRequest) { // Mozilla, Safari, etc... request = new XMLHttpRequest(); } else if (window.ActiveXObject) { // IE try { request = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;); } catch (e) { try { request = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); } catch (e) {} } } // Ouvre la demande et l&#39;envoie request.open(&#39;GET&#39;, &#39;https://example.com/api&#39;, true); request.send(null); Bien sûr, les frameworks JavaScript rendent l’API XHR plus agréable à utiliser, mais ce que vous voyez ci-dessus est un exemple “simple” de l’utilisation la plus basique de XHR. XHR est un vrai gâchis. Utilisation de base de fetch L’API fetch est fournie dans l’objet window globale, le premier argument étant l’URL (obligatoire) et le second les options (facultatif). // fetch(url, options) | url: obligatoire - options: facultatif fetch(&#39;https://example.com/api&#39;, { method: &#39;get&#39; }).then(function(response) { // Succès :) }).catch(function(err) { // Erreur :( }); Et comme vous pouvez le voir, fetch utilise les promesses Javascript pour gérer les résultats et les callbacks. Si vous n’êtes pas encore habitué aux promesses Javascript, habituez-vous - elles seront bientôt partout. En-têtes de requête La possibilité de définir des en-têtes de requête est importante dans la flexibilité de la requête, vous pouvez travailler avec les en-têtes de requête en exécutant new Headers() // Créer une instance d&#39;en-têtes vide const headers = new Headers(); // Ajouter des en-têtes headers.append(&#39;EnTeteCustom&#39;, &#39;MaSuperValeur&#39;); headers.append(&#39;Content-Type&#39;, &#39;text/html&#39;); // Vérifier si cet en-tête est présent headers.has(&#39;Content-Type&#39;); // vrai headers.has(&#39;Some-Header&#39;); // faux // Obtenir la valeur d&#39;un en-tête spécifique headers.get(&#39;EnTeteCustom&#39;); // MaSuperValeur // Définir une nouvelle valeur pour un en-tête existant headers.set(&#39;Content-Type&#39;, &#39;text/plain&#39;); // Supprimer une en-tête headers.delete(&#39;EnTeteCustom&#39;); // Additionner les valeurs initiales const headers = new Headers({ &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;MonSuperUserAgent&#39; }); Pour utiliser les en-têtes de Request, vous devez d’abord créer une nouvelle instance de Request const request = new Request(&#39;https://example.com/api&#39;, { headers: new Headers({ &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;MonSuperUserAgent&#39; }) }); fetch(request).then(function(response) { // traiter la réponse }).catch(function(error) { // traiter l&#39;erreur }); Requête Une instance de Request représente l’élément de requête d’un appel de la méthode fetch. En passant une Request à l’API fetch, vous pouvez faire des demandes avancées et personnalisées: method - GET, HEAD, POST, PUT, DELETE url - URL de la requête headers - objet Headers associé referrer - référant de la requête mode - cors, no-cors, same-origin credentials - les cookies doivent-ils accompagner la demande ? omit, same-origin redirect - follow, error, manual integrity - valeur d’intégrité des sous-ressources cache - mode du cache (default, reload, no-cache) Voici un exemple d’utilisation de Request // Construire la requête const request = new Request(&#39;https://example.com/anything&#39;, { method: &#39;HEAD&#39;, mode: &#39;no-cors&#39;, redirect: &#39;follow&#39;, headers: new Headers({ &#39;Content-Type&#39;: &#39;text/html&#39; }) }); // Et maintenant, utilisez la requête fetch(request).then(function() { // handle response }); Seul le premier paramètre, l’URL, est requis. Chaque propriété ne peut être que lu dès que l’instance de la Request a été créée. Il est également important de noter que Request a une méthode de clonage qui est importante lors de l’utilisation de fetch dans l’API Service Worker - une Request est un flux et doit donc être clonée lors du passage à un autre appel de fetch. fetch(&#39;https://example.com/anything&#39;, { method: &#39;HEAD&#39;, mode: &#39;no-cors&#39;, redirect: &#39;follow&#39;, headers: new Headers({ &#39;Content-Type&#39;: &#39;text/html&#39; }) }).then(function() { // gérer la réponse }); Vous n’utiliserez probablement que des instances de Request au sein de Service Workers puisque les signatures Request et fetch peuvent être les mêmes. Réponse La méthode then de fetch est une instance de réponse mais vous pouvez également créer manuellement des objets de réponse vous-même – une autre situation que vous pouvez rencontrer lorsque vous utilisez des service workers. Avec une réponse, vous pouvez configurer: type - basic, cors url useFinalURL - Booléen pour si url est l’URL finale. status - code de statut (ex: 200, 404, etc.) ok - Booléen pour une réponse réussie (statut dans la plage 200-299) statusText - code de statut (ex: OK) headers - Objet d’en-tête associé à la réponse. // Fausse réponse pour les tests des service workers -- new Response(body, options) const response = new Response(&#39;response body&#39;, { ok: false, status: 404, url: &#39;/&#39; }); // Le then de fetch récupère alors une instance de réponse. fetch(&#39;https://exemple.com/&#39;).then(function(response) { console.log(&#39;ok: &#39;, response.ok); // faux }); La Response fournit également les méthodes suivantes : clone() Crée un clone d’un objet Response error() Retourne un nouvel objet Response associé à une erreur réseau redirect() Crée une nouvelle réponse avec une URL différente. arrayBuffer() Retourne une promesse qui se résout avec un ArrayBuffer. blob() Retourne une promesse qui se résout avec un Blob. formData() Retourne une promesse qui se résout avec un objet FormData. json() Retourne une promesse qui se résout avec un objet JSON. text() Retourne une promesse qui se résout avec une USVString (texte) Manipulation du JSON Disons que vous faites une requête pour JSON, les données de rappel résultantes ont une méthode json pour convertir les données brutes en objet JavaScript fetch(&#39;https://example.com/api/list.json&#39;).then(function(response) { // Convertir en JSON return response.json(); }).then(function(jsObj) { // jsObj est un objet javascript de la réponse json console.log(jsObj); }); La méthode json() est un simple raccourci vers JSON.parse(jsonString) Manipulation des réponses Text/HTML JSON n’est pas toujours le format de réponse désiré, alors voici comment vous pouvez travailler avec une réponse HTML ou textuelle fetch(&#39;/404&#39;).then(function(response) { return response.text(); }).then(function(htmlresponse) { // &lt;!DOCTYPE .... console.log(htmlresponse); }); Vous pouvez obtenir le texte de réponse enchaînant la méthode then de la promesse avec la méthode text() Manipulation des réponses Blob Par exemple, charger une image via fetch est un peu différent fetch(&#39;https://example.com/someimage.jpg&#39;).then(function(response) { return response.blob(); }) .then(function(imageBlob) { document.querySelector(&#39;img&#39;).src = URL.createObjectURL(imageBlob); }); La méthode blob() du Body mixing prend un flux de réponse et le lit jusqu’à la fin. Envoyer des données de formulaire AJAX est beaucoup utilisé pour envoyer des données de formulaire, voici comment vous le feriez avec l’utilisation de fetch fetch(&#39;https://example.com/submit&#39;, { method: &#39;post&#39;, body: new FormData(document.getElementById(&#39;myForm&#39;)) }); Et si vous voulez poster des données JSON fetch(&#39;https://example.com/submit&#39;, { method: &#39;post&#39;, body: JSON.stringify({ some: document.querySelector(&#39;#some&#39;).value, json: document.querySelector(&#39;#json&#39;).value, data: document.querySelector(&#39;#data&#39;).value }) }); C’est aussi simple que ça ! Polyfill Il y a beaucoup de Polyfill pour la méthode fetch, mais je vous suggère fortement de vous pencher sur celle de GitHub." />
<meta property="og:description" content="L’API XHR la plus populaire est XMLHttpRequest qui n’a pas vraiment été faite pour ce pour quoi nous l’utilisons. C’est pourquoi l’API fetch a été créée, l’API fetch est en quelque sorte un remplacement moderne pour XMLHttpRequest. Jetons un coup d’oeil à cette méthode window.fetch. Compatibilité des navigateurs Une chose importante lors du développement d’une application web est la compatibilité du navigateur avec les technologies utilisées. Comme XMLHttpRequest est plus ancien, il a logiquement une meilleure compatibilité avec les navigateurs plus anciens par rapport à fetch, cependant, il y a des polyfill’s bien faits qui rendent cette API moderne compatible avec les navigateurs plus anciens tels que IE, etc… (c.f Compatibilité XMLHttpRequesty, Compatibilité Fetch) Utilisation de base de XMLHttpRequest XHR est un peu trop compliqué à mon avis et je ne comprends toujours pas pourquoi XML est en majuscules alors que Http est en camel-case, cela n’a aucun sens. Quoi qu’il en soit, voici un usage courant de l’API XHR if (window.XMLHttpRequest) { // Mozilla, Safari, etc... request = new XMLHttpRequest(); } else if (window.ActiveXObject) { // IE try { request = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;); } catch (e) { try { request = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); } catch (e) {} } } // Ouvre la demande et l&#39;envoie request.open(&#39;GET&#39;, &#39;https://example.com/api&#39;, true); request.send(null); Bien sûr, les frameworks JavaScript rendent l’API XHR plus agréable à utiliser, mais ce que vous voyez ci-dessus est un exemple “simple” de l’utilisation la plus basique de XHR. XHR est un vrai gâchis. Utilisation de base de fetch L’API fetch est fournie dans l’objet window globale, le premier argument étant l’URL (obligatoire) et le second les options (facultatif). // fetch(url, options) | url: obligatoire - options: facultatif fetch(&#39;https://example.com/api&#39;, { method: &#39;get&#39; }).then(function(response) { // Succès :) }).catch(function(err) { // Erreur :( }); Et comme vous pouvez le voir, fetch utilise les promesses Javascript pour gérer les résultats et les callbacks. Si vous n’êtes pas encore habitué aux promesses Javascript, habituez-vous - elles seront bientôt partout. En-têtes de requête La possibilité de définir des en-têtes de requête est importante dans la flexibilité de la requête, vous pouvez travailler avec les en-têtes de requête en exécutant new Headers() // Créer une instance d&#39;en-têtes vide const headers = new Headers(); // Ajouter des en-têtes headers.append(&#39;EnTeteCustom&#39;, &#39;MaSuperValeur&#39;); headers.append(&#39;Content-Type&#39;, &#39;text/html&#39;); // Vérifier si cet en-tête est présent headers.has(&#39;Content-Type&#39;); // vrai headers.has(&#39;Some-Header&#39;); // faux // Obtenir la valeur d&#39;un en-tête spécifique headers.get(&#39;EnTeteCustom&#39;); // MaSuperValeur // Définir une nouvelle valeur pour un en-tête existant headers.set(&#39;Content-Type&#39;, &#39;text/plain&#39;); // Supprimer une en-tête headers.delete(&#39;EnTeteCustom&#39;); // Additionner les valeurs initiales const headers = new Headers({ &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;MonSuperUserAgent&#39; }); Pour utiliser les en-têtes de Request, vous devez d’abord créer une nouvelle instance de Request const request = new Request(&#39;https://example.com/api&#39;, { headers: new Headers({ &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;MonSuperUserAgent&#39; }) }); fetch(request).then(function(response) { // traiter la réponse }).catch(function(error) { // traiter l&#39;erreur }); Requête Une instance de Request représente l’élément de requête d’un appel de la méthode fetch. En passant une Request à l’API fetch, vous pouvez faire des demandes avancées et personnalisées: method - GET, HEAD, POST, PUT, DELETE url - URL de la requête headers - objet Headers associé referrer - référant de la requête mode - cors, no-cors, same-origin credentials - les cookies doivent-ils accompagner la demande ? omit, same-origin redirect - follow, error, manual integrity - valeur d’intégrité des sous-ressources cache - mode du cache (default, reload, no-cache) Voici un exemple d’utilisation de Request // Construire la requête const request = new Request(&#39;https://example.com/anything&#39;, { method: &#39;HEAD&#39;, mode: &#39;no-cors&#39;, redirect: &#39;follow&#39;, headers: new Headers({ &#39;Content-Type&#39;: &#39;text/html&#39; }) }); // Et maintenant, utilisez la requête fetch(request).then(function() { // handle response }); Seul le premier paramètre, l’URL, est requis. Chaque propriété ne peut être que lu dès que l’instance de la Request a été créée. Il est également important de noter que Request a une méthode de clonage qui est importante lors de l’utilisation de fetch dans l’API Service Worker - une Request est un flux et doit donc être clonée lors du passage à un autre appel de fetch. fetch(&#39;https://example.com/anything&#39;, { method: &#39;HEAD&#39;, mode: &#39;no-cors&#39;, redirect: &#39;follow&#39;, headers: new Headers({ &#39;Content-Type&#39;: &#39;text/html&#39; }) }).then(function() { // gérer la réponse }); Vous n’utiliserez probablement que des instances de Request au sein de Service Workers puisque les signatures Request et fetch peuvent être les mêmes. Réponse La méthode then de fetch est une instance de réponse mais vous pouvez également créer manuellement des objets de réponse vous-même – une autre situation que vous pouvez rencontrer lorsque vous utilisez des service workers. Avec une réponse, vous pouvez configurer: type - basic, cors url useFinalURL - Booléen pour si url est l’URL finale. status - code de statut (ex: 200, 404, etc.) ok - Booléen pour une réponse réussie (statut dans la plage 200-299) statusText - code de statut (ex: OK) headers - Objet d’en-tête associé à la réponse. // Fausse réponse pour les tests des service workers -- new Response(body, options) const response = new Response(&#39;response body&#39;, { ok: false, status: 404, url: &#39;/&#39; }); // Le then de fetch récupère alors une instance de réponse. fetch(&#39;https://exemple.com/&#39;).then(function(response) { console.log(&#39;ok: &#39;, response.ok); // faux }); La Response fournit également les méthodes suivantes : clone() Crée un clone d’un objet Response error() Retourne un nouvel objet Response associé à une erreur réseau redirect() Crée une nouvelle réponse avec une URL différente. arrayBuffer() Retourne une promesse qui se résout avec un ArrayBuffer. blob() Retourne une promesse qui se résout avec un Blob. formData() Retourne une promesse qui se résout avec un objet FormData. json() Retourne une promesse qui se résout avec un objet JSON. text() Retourne une promesse qui se résout avec une USVString (texte) Manipulation du JSON Disons que vous faites une requête pour JSON, les données de rappel résultantes ont une méthode json pour convertir les données brutes en objet JavaScript fetch(&#39;https://example.com/api/list.json&#39;).then(function(response) { // Convertir en JSON return response.json(); }).then(function(jsObj) { // jsObj est un objet javascript de la réponse json console.log(jsObj); }); La méthode json() est un simple raccourci vers JSON.parse(jsonString) Manipulation des réponses Text/HTML JSON n’est pas toujours le format de réponse désiré, alors voici comment vous pouvez travailler avec une réponse HTML ou textuelle fetch(&#39;/404&#39;).then(function(response) { return response.text(); }).then(function(htmlresponse) { // &lt;!DOCTYPE .... console.log(htmlresponse); }); Vous pouvez obtenir le texte de réponse enchaînant la méthode then de la promesse avec la méthode text() Manipulation des réponses Blob Par exemple, charger une image via fetch est un peu différent fetch(&#39;https://example.com/someimage.jpg&#39;).then(function(response) { return response.blob(); }) .then(function(imageBlob) { document.querySelector(&#39;img&#39;).src = URL.createObjectURL(imageBlob); }); La méthode blob() du Body mixing prend un flux de réponse et le lit jusqu’à la fin. Envoyer des données de formulaire AJAX est beaucoup utilisé pour envoyer des données de formulaire, voici comment vous le feriez avec l’utilisation de fetch fetch(&#39;https://example.com/submit&#39;, { method: &#39;post&#39;, body: new FormData(document.getElementById(&#39;myForm&#39;)) }); Et si vous voulez poster des données JSON fetch(&#39;https://example.com/submit&#39;, { method: &#39;post&#39;, body: JSON.stringify({ some: document.querySelector(&#39;#some&#39;).value, json: document.querySelector(&#39;#json&#39;).value, data: document.querySelector(&#39;#data&#39;).value }) }); C’est aussi simple que ça ! Polyfill Il y a beaucoup de Polyfill pour la méthode fetch, mais je vous suggère fortement de vous pencher sur celle de GitHub." />
<link rel="canonical" href="https://xela.isfucking.cool/blog/fr/fetch-api" />
<meta property="og:url" content="https://xela.isfucking.cool/blog/fr/fetch-api" />
<meta property="og:site_name" content="Xela’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-10T00:00:00+02:00" />
<script type="application/ld+json">
{"description":"L’API XHR la plus populaire est XMLHttpRequest qui n’a pas vraiment été faite pour ce pour quoi nous l’utilisons. C’est pourquoi l’API fetch a été créée, l’API fetch est en quelque sorte un remplacement moderne pour XMLHttpRequest. Jetons un coup d’oeil à cette méthode window.fetch. Compatibilité des navigateurs Une chose importante lors du développement d’une application web est la compatibilité du navigateur avec les technologies utilisées. Comme XMLHttpRequest est plus ancien, il a logiquement une meilleure compatibilité avec les navigateurs plus anciens par rapport à fetch, cependant, il y a des polyfill’s bien faits qui rendent cette API moderne compatible avec les navigateurs plus anciens tels que IE, etc… (c.f Compatibilité XMLHttpRequesty, Compatibilité Fetch) Utilisation de base de XMLHttpRequest XHR est un peu trop compliqué à mon avis et je ne comprends toujours pas pourquoi XML est en majuscules alors que Http est en camel-case, cela n’a aucun sens. Quoi qu’il en soit, voici un usage courant de l’API XHR if (window.XMLHttpRequest) { // Mozilla, Safari, etc... request = new XMLHttpRequest(); } else if (window.ActiveXObject) { // IE try { request = new ActiveXObject(&#39;Msxml2.XMLHTTP&#39;); } catch (e) { try { request = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); } catch (e) {} } } // Ouvre la demande et l&#39;envoie request.open(&#39;GET&#39;, &#39;https://example.com/api&#39;, true); request.send(null); Bien sûr, les frameworks JavaScript rendent l’API XHR plus agréable à utiliser, mais ce que vous voyez ci-dessus est un exemple “simple” de l’utilisation la plus basique de XHR. XHR est un vrai gâchis. Utilisation de base de fetch L’API fetch est fournie dans l’objet window globale, le premier argument étant l’URL (obligatoire) et le second les options (facultatif). // fetch(url, options) | url: obligatoire - options: facultatif fetch(&#39;https://example.com/api&#39;, { method: &#39;get&#39; }).then(function(response) { // Succès :) }).catch(function(err) { // Erreur :( }); Et comme vous pouvez le voir, fetch utilise les promesses Javascript pour gérer les résultats et les callbacks. Si vous n’êtes pas encore habitué aux promesses Javascript, habituez-vous - elles seront bientôt partout. En-têtes de requête La possibilité de définir des en-têtes de requête est importante dans la flexibilité de la requête, vous pouvez travailler avec les en-têtes de requête en exécutant new Headers() // Créer une instance d&#39;en-têtes vide const headers = new Headers(); // Ajouter des en-têtes headers.append(&#39;EnTeteCustom&#39;, &#39;MaSuperValeur&#39;); headers.append(&#39;Content-Type&#39;, &#39;text/html&#39;); // Vérifier si cet en-tête est présent headers.has(&#39;Content-Type&#39;); // vrai headers.has(&#39;Some-Header&#39;); // faux // Obtenir la valeur d&#39;un en-tête spécifique headers.get(&#39;EnTeteCustom&#39;); // MaSuperValeur // Définir une nouvelle valeur pour un en-tête existant headers.set(&#39;Content-Type&#39;, &#39;text/plain&#39;); // Supprimer une en-tête headers.delete(&#39;EnTeteCustom&#39;); // Additionner les valeurs initiales const headers = new Headers({ &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;MonSuperUserAgent&#39; }); Pour utiliser les en-têtes de Request, vous devez d’abord créer une nouvelle instance de Request const request = new Request(&#39;https://example.com/api&#39;, { headers: new Headers({ &#39;Content-Type&#39;: &#39;application/json&#39;, &#39;User-Agent&#39;: &#39;MonSuperUserAgent&#39; }) }); fetch(request).then(function(response) { // traiter la réponse }).catch(function(error) { // traiter l&#39;erreur }); Requête Une instance de Request représente l’élément de requête d’un appel de la méthode fetch. En passant une Request à l’API fetch, vous pouvez faire des demandes avancées et personnalisées: method - GET, HEAD, POST, PUT, DELETE url - URL de la requête headers - objet Headers associé referrer - référant de la requête mode - cors, no-cors, same-origin credentials - les cookies doivent-ils accompagner la demande ? omit, same-origin redirect - follow, error, manual integrity - valeur d’intégrité des sous-ressources cache - mode du cache (default, reload, no-cache) Voici un exemple d’utilisation de Request // Construire la requête const request = new Request(&#39;https://example.com/anything&#39;, { method: &#39;HEAD&#39;, mode: &#39;no-cors&#39;, redirect: &#39;follow&#39;, headers: new Headers({ &#39;Content-Type&#39;: &#39;text/html&#39; }) }); // Et maintenant, utilisez la requête fetch(request).then(function() { // handle response }); Seul le premier paramètre, l’URL, est requis. Chaque propriété ne peut être que lu dès que l’instance de la Request a été créée. Il est également important de noter que Request a une méthode de clonage qui est importante lors de l’utilisation de fetch dans l’API Service Worker - une Request est un flux et doit donc être clonée lors du passage à un autre appel de fetch. fetch(&#39;https://example.com/anything&#39;, { method: &#39;HEAD&#39;, mode: &#39;no-cors&#39;, redirect: &#39;follow&#39;, headers: new Headers({ &#39;Content-Type&#39;: &#39;text/html&#39; }) }).then(function() { // gérer la réponse }); Vous n’utiliserez probablement que des instances de Request au sein de Service Workers puisque les signatures Request et fetch peuvent être les mêmes. Réponse La méthode then de fetch est une instance de réponse mais vous pouvez également créer manuellement des objets de réponse vous-même – une autre situation que vous pouvez rencontrer lorsque vous utilisez des service workers. Avec une réponse, vous pouvez configurer: type - basic, cors url useFinalURL - Booléen pour si url est l’URL finale. status - code de statut (ex: 200, 404, etc.) ok - Booléen pour une réponse réussie (statut dans la plage 200-299) statusText - code de statut (ex: OK) headers - Objet d’en-tête associé à la réponse. // Fausse réponse pour les tests des service workers -- new Response(body, options) const response = new Response(&#39;response body&#39;, { ok: false, status: 404, url: &#39;/&#39; }); // Le then de fetch récupère alors une instance de réponse. fetch(&#39;https://exemple.com/&#39;).then(function(response) { console.log(&#39;ok: &#39;, response.ok); // faux }); La Response fournit également les méthodes suivantes : clone() Crée un clone d’un objet Response error() Retourne un nouvel objet Response associé à une erreur réseau redirect() Crée une nouvelle réponse avec une URL différente. arrayBuffer() Retourne une promesse qui se résout avec un ArrayBuffer. blob() Retourne une promesse qui se résout avec un Blob. formData() Retourne une promesse qui se résout avec un objet FormData. json() Retourne une promesse qui se résout avec un objet JSON. text() Retourne une promesse qui se résout avec une USVString (texte) Manipulation du JSON Disons que vous faites une requête pour JSON, les données de rappel résultantes ont une méthode json pour convertir les données brutes en objet JavaScript fetch(&#39;https://example.com/api/list.json&#39;).then(function(response) { // Convertir en JSON return response.json(); }).then(function(jsObj) { // jsObj est un objet javascript de la réponse json console.log(jsObj); }); La méthode json() est un simple raccourci vers JSON.parse(jsonString) Manipulation des réponses Text/HTML JSON n’est pas toujours le format de réponse désiré, alors voici comment vous pouvez travailler avec une réponse HTML ou textuelle fetch(&#39;/404&#39;).then(function(response) { return response.text(); }).then(function(htmlresponse) { // &lt;!DOCTYPE .... console.log(htmlresponse); }); Vous pouvez obtenir le texte de réponse enchaînant la méthode then de la promesse avec la méthode text() Manipulation des réponses Blob Par exemple, charger une image via fetch est un peu différent fetch(&#39;https://example.com/someimage.jpg&#39;).then(function(response) { return response.blob(); }) .then(function(imageBlob) { document.querySelector(&#39;img&#39;).src = URL.createObjectURL(imageBlob); }); La méthode blob() du Body mixing prend un flux de réponse et le lit jusqu’à la fin. Envoyer des données de formulaire AJAX est beaucoup utilisé pour envoyer des données de formulaire, voici comment vous le feriez avec l’utilisation de fetch fetch(&#39;https://example.com/submit&#39;, { method: &#39;post&#39;, body: new FormData(document.getElementById(&#39;myForm&#39;)) }); Et si vous voulez poster des données JSON fetch(&#39;https://example.com/submit&#39;, { method: &#39;post&#39;, body: JSON.stringify({ some: document.querySelector(&#39;#some&#39;).value, json: document.querySelector(&#39;#json&#39;).value, data: document.querySelector(&#39;#data&#39;).value }) }); C’est aussi simple que ça ! Polyfill Il y a beaucoup de Polyfill pour la méthode fetch, mais je vous suggère fortement de vous pencher sur celle de GitHub.","@type":"BlogPosting","url":"https://xela.isfucking.cool/blog/fr/fetch-api","headline":"Cesser d’utiliser XMLHttpRequest et passer à fetch","dateModified":"2018-08-10T00:00:00+02:00","datePublished":"2018-08-10T00:00:00+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://xela.isfucking.cool/blog/fr/fetch-api"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" /><link rel="apple-touch-icon" href="/apple-touch-icon.png" /><link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" /><link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" /><link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" /><link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" /><link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" /><link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" /><link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" /><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" /> <meta name="google-site-verification" content="1zl4FVbvtiysR1NlQ35IbrEsqAXoObC-oACu2TRUkZo" /><link defer href="https://fonts.googleapis.com/css?family=Alegreya" rel="stylesheet"><link defer href="https://fonts.googleapis.com/css?family=Fira+Mono" rel="stylesheet"><link defer href="https://fonts.googleapis.com/css?family=Nunito" rel="stylesheet"><script type="text/javascript" src="/js/app.js"></script><link rel="stylesheet" href="/css/post.css" /><title>Cesser d'utiliser XMLHttpRequest et passer à fetch | Xela's Blog</title></head><body>
<main> <article><h1>Cesser d'utiliser XMLHttpRequest et passer à fetch</h1> <nav> <a href="/fr"> <i class="fa fa-chevron-left" style="font-size:0.7em"></i> Retournez à l'accueil</a> </nav><div><p>L’API XHR la plus populaire est <code>XMLHttpRequest</code> qui n’a pas vraiment été faite pour ce pour quoi nous l’utilisons. C’est pourquoi l’API <code>fetch</code> a été créée, l’API <code>fetch</code> est en quelque sorte un remplacement moderne pour <code>XMLHttpRequest</code>. Jetons un coup d’oeil à cette méthode <code>window.fetch</code>.</p>

<h2 id="compatibilité-des-navigateurs">Compatibilité des navigateurs</h2>

<p>Une chose importante lors du développement d’une application web est la compatibilité du navigateur avec les technologies utilisées. Comme <code>XMLHttpRequest</code> est plus ancien, il a logiquement une meilleure compatibilité avec les navigateurs plus anciens par rapport à <code>fetch</code>, cependant, il y a des polyfill’s bien faits qui rendent cette API moderne compatible avec les navigateurs plus anciens tels que IE, etc…</p>

<p>(c.f <a href="https://caniuse.com/#search=XMLHttpRequest">Compatibilité XMLHttpRequesty</a>, <a href="https://caniuse.com/#search=Fetch">Compatibilité Fetch</a>)</p>

<h2 id="utilisation-de-base-de-xmlhttprequest">Utilisation de base de <code>XMLHttpRequest</code></h2>

<p>XHR est un peu trop compliqué à mon avis et je ne comprends toujours pas pourquoi <code>XML</code> est en majuscules alors que <code>Http</code> est en camel-case, cela n’a aucun sens. Quoi qu’il en soit, voici un usage courant de l’API XHR</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (window.XMLHttpRequest) { // Mozilla, Safari, etc...
request = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
try {
    request = new ActiveXObject('Msxml2.XMLHTTP');
} 
catch (e) {
    try {
    request = new ActiveXObject('Microsoft.XMLHTTP');
    } 
    catch (e) {}
}
}

// Ouvre la demande et l'envoie
request.open('GET', 'https://example.com/api', true);
request.send(null);
</code></pre></div></div>

<p>Bien sûr, les frameworks JavaScript rendent l’API XHR plus agréable à utiliser, mais ce que vous voyez ci-dessus est un exemple “<strong>simple</strong>” de l’utilisation la plus basique de XHR. XHR est un vrai gâchis.</p>

<h2 id="utilisation-de-base-de-fetch">Utilisation de base de <code>fetch</code></h2>

<p>L’API <code>fetch</code> est fournie dans l’objet <code>window</code> globale, le premier argument étant l’URL (obligatoire) et le second les options (facultatif).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// fetch(url, options) | url: obligatoire - options: facultatif
fetch('https://example.com/api', {
    method: 'get'
}).then(function(response) {
    // Succès :)
}).catch(function(err) {
    // Erreur :(
});
</code></pre></div></div>

<p>Et comme vous pouvez le voir, <code>fetch</code> utilise les promesses Javascript pour gérer les résultats et les callbacks. Si vous n’êtes pas encore habitué aux promesses Javascript, habituez-vous - elles seront bientôt partout.</p>

<h2 id="en-têtes-de-requête">En-têtes de requête</h2>

<p>La possibilité de définir des en-têtes de requête est importante dans la flexibilité de la requête, vous pouvez travailler avec les en-têtes de requête en exécutant <code>new Headers()</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Créer une instance d'en-têtes vide
const headers = new Headers();

// Ajouter des en-têtes
headers.append('EnTeteCustom', 'MaSuperValeur');
headers.append('Content-Type', 'text/html');

// Vérifier si cet en-tête est présent
headers.has('Content-Type'); // vrai
headers.has('Some-Header'); // faux

// Obtenir la valeur d'un en-tête spécifique
headers.get('EnTeteCustom'); // MaSuperValeur

// Définir une nouvelle valeur pour un en-tête existant
headers.set('Content-Type', 'text/plain');

// Supprimer une en-tête
headers.delete('EnTeteCustom');

// Additionner les valeurs initiales
const headers = new Headers({
    'Content-Type': 'application/json',
    'User-Agent': 'MonSuperUserAgent'
});
</code></pre></div></div>

<p>Pour utiliser les en-têtes de Request, vous devez d’abord créer une nouvelle instance de <code>Request</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>const request = new Request('https://example.com/api', {
    headers: new Headers({
        'Content-Type': 'application/json',
        'User-Agent': 'MonSuperUserAgent'
    })
});

fetch(request).then(function(response) {
    // traiter la réponse
}).catch(function(error) {
    // traiter l'erreur
});
</code></pre></div></div>

<h2 id="requête">Requête</h2>

<p>Une instance de <code>Request</code> représente l’élément de requête d’un appel de la méthode <code>fetch</code>. En passant une <code>Request</code> à l’API fetch, vous pouvez faire des demandes avancées et personnalisées:</p>

<ul>
  <li><code>method</code> - <strong>GET</strong>, <strong>HEAD</strong>, <strong>POST</strong>, <strong>PUT</strong>, <strong>DELETE</strong></li>
  <li><code>url</code> - <strong>URL</strong> de la requête</li>
  <li><code>headers</code> - objet <strong>Headers</strong> associé</li>
  <li><code>referrer</code> - référant de la requête</li>
  <li><code>mode</code> - <strong>cors</strong>, <strong>no-cors</strong>, <strong>same-origin</strong></li>
  <li><code>credentials</code> - les cookies doivent-ils accompagner la demande ? <strong>omit</strong>, <strong>same-origin</strong></li>
  <li><code>redirect</code> - <strong>follow</strong>, <strong>error</strong>, <strong>manual</strong></li>
  <li><code>integrity</code> - valeur d’intégrité des sous-ressources</li>
  <li><code>cache</code> - mode du cache (<strong>default</strong>, <strong>reload</strong>, <strong>no-cache</strong>)</li>
</ul>

<p>Voici un exemple d’utilisation de <code>Request</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Construire la requête
const request = new Request('https://example.com/anything', {
    method: 'HEAD', 
    mode: 'no-cors', 
    redirect: 'follow',
    headers: new Headers({
        'Content-Type': 'text/html'
    })
});

// Et maintenant, utilisez la requête
fetch(request).then(function() {
    // handle response 
});
</code></pre></div></div>

<p>Seul le premier paramètre, l’URL, est requis. Chaque propriété ne peut être que lu dès que l’instance de la <code>Request</code> a été créée. Il est également important de noter que <code>Request</code> a une méthode de clonage qui est importante lors de l’utilisation de <code>fetch</code> dans l’API Service Worker - une <code>Request</code> est un flux et doit donc être clonée lors du passage à un autre appel de <code>fetch</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('https://example.com/anything', {
    method: 'HEAD', 
    mode: 'no-cors', 
    redirect: 'follow',
    headers: new Headers({
        'Content-Type': 'text/html'
    })
}).then(function() {
    // gérer la réponse 
});
</code></pre></div></div>

<p>Vous n’utiliserez probablement que des instances de Request au sein de Service Workers puisque les signatures Request et fetch peuvent être les mêmes.</p>

<h2 id="réponse">Réponse</h2>

<p>La méthode then de fetch est une instance de réponse mais vous pouvez également créer manuellement des objets de réponse vous-même – une autre situation que vous pouvez rencontrer lorsque vous utilisez des service workers. Avec une réponse, vous pouvez configurer:</p>

<ul>
  <li><code>type</code> - <strong>basic</strong>, <strong>cors</strong></li>
  <li><code>url</code></li>
  <li><code>useFinalURL</code> - Booléen pour si <strong>url</strong> est l’URL finale.</li>
  <li><code>status</code> - code de statut (ex: <strong>200</strong>, <strong>404</strong>, etc.)</li>
  <li><code>ok</code> - Booléen pour une réponse réussie (statut dans la plage 200-299)</li>
  <li><code>statusText</code> - code de statut (ex: <strong>OK</strong>)</li>
  <li><code>headers</code> - Objet d’en-tête associé à la réponse.</li>
</ul>

<pre><code>// Fausse réponse pour les tests des service workers -- new Response(body, options)
const response = new Response('response body', {
	ok: false,
	status: 404,
	url: '/'
});

// Le then de fetch récupère alors une instance de réponse.
fetch('https://exemple.com/').then(function(response) {
	console.log('ok: ', response.ok); // faux
});</code></pre>

<p>La <code>Response</code> fournit également les méthodes suivantes :</p>

<ul>
  <li>clone() Crée un clone d’un objet Response</li>
  <li>error() Retourne un nouvel objet Response associé à une erreur réseau</li>
  <li>redirect() Crée une nouvelle réponse avec une URL différente.</li>
  <li>arrayBuffer() Retourne une promesse qui se résout avec un ArrayBuffer.</li>
  <li>blob() Retourne une promesse qui se résout avec un Blob.</li>
  <li>formData() Retourne une promesse qui se résout avec un objet FormData.</li>
  <li>json() Retourne une promesse qui se résout avec un objet JSON.</li>
  <li>text() Retourne une promesse qui se résout avec une USVString (texte)</li>
</ul>

<h2 id="manipulation-du-json">Manipulation du JSON</h2>

<p>Disons que vous faites une requête pour JSON, les données de rappel résultantes ont une méthode json pour convertir les données brutes en objet JavaScript</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('https://example.com/api/list.json').then(function(response) { 
    // Convertir en JSON
    return response.json();
}).then(function(jsObj) {
    // jsObj est un objet javascript de la réponse json
    console.log(jsObj); 
});
</code></pre></div></div>

<p>La méthode <code>json()</code> est un simple raccourci vers <code>JSON.parse(jsonString)</code></p>

<h2 id="manipulation-des-réponses-texthtml">Manipulation des réponses Text/HTML</h2>

<p>JSON n’est pas toujours le format de réponse désiré, alors voici comment vous pouvez travailler avec une réponse HTML ou textuelle</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('/404').then(function(response) {
    return response.text();
}).then(function(htmlresponse) { 
    // &lt;!DOCTYPE ....
    console.log(htmlresponse); 
});
</code></pre></div></div>

<p>Vous pouvez obtenir le texte de réponse enchaînant la méthode <code>then</code> de la promesse avec la méthode <code>text()</code></p>

<h2 id="manipulation-des-réponses-blob">Manipulation des réponses Blob</h2>

<p>Par exemple, charger une image via fetch est un peu différent</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('https://example.com/someimage.jpg').then(function(response) {
    return response.blob();
})
.then(function(imageBlob) {
    document.querySelector('img').src = URL.createObjectURL(imageBlob);
});
</code></pre></div></div>

<p>La méthode <code>blob()</code> du Body mixing prend un flux de réponse et le lit jusqu’à la fin.</p>

<h2 id="envoyer-des-données-de-formulaire">Envoyer des données de formulaire</h2>

<p>AJAX est beaucoup utilisé pour envoyer des données de formulaire, voici comment vous le feriez avec l’utilisation de fetch</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('https://example.com/submit', {
    method: 'post',
    body: new FormData(document.getElementById('myForm'))
});
</code></pre></div></div>

<p>Et si vous voulez poster des données JSON</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fetch('https://example.com/submit', {
    method: 'post',
    body: JSON.stringify({
        some: document.querySelector('#some').value,
        json: document.querySelector('#json').value,
        data: document.querySelector('#data').value
    })
});
</code></pre></div></div>

<p>C’est aussi simple que ça !</p>

<h2 id="polyfill">Polyfill</h2>

<p>Il y a beaucoup de Polyfill pour la méthode fetch, mais je vous suggère fortement de vous pencher sur celle de <a href="https://github.com/github/fetch">GitHub</a>.</p>
</div> </article> </main><footer><div style="text-align: center"><p id="loadtime"></p><p> s'abonner <a href="/fr/feed.xml">via RSS</a> - <a href="/en" id="r">EN Version</a></p></div> </footer><script>document.querySelector("#r").addEventListener("click", function (a) { a.preventDefault(); var b = window.location.pathname; nurl = 0 <= b.indexOf("/fr/") ? b.replace("/fr/", "/en/") : 0 <= b.indexOf("/en/") ? b.replace("/en/", "/fr/") : "/fr", window.location = nurl }); hljs.initHighlightingOnLoad(), hljs.initLineNumbersOnLoad({ singleLine: !0 }), window.onload = function () { for (var n = document.links, i = 0, e = n.length; e > i; i++)n[i].hostname != window.location.hostname && (n[i].innerHTML += ' <i class="fa fa-external-link" style="font-size:0.7em"></i>'); setTimeout(function () { var a = window.performance && performance.timing, b = (a.loadEventEnd - a.navigationStart) / 1e3; document.querySelector("#loadtime").innerHTML = "Cette page a été chargée en " + b + " secondes" }, 0); }</script></body></html>