<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no" />
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Cesser d’utiliser XMLHttpRequest et passer à fetch | Alexandre’s Blog</title>
<meta name="generator" content="Jekyll v4.3.2" />
<meta property="og:title" content="Cesser d’utiliser XMLHttpRequest et passer à fetch" />
<meta name="author" content="Alexandre CIPOR" />
<meta property="og:locale" content="fr_FR" />
<meta name="description" content="L’API XHR la plus populaire est XMLHttpRequest qui n’a pas vraiment été faite pour ce pour quoi nous l’utilisons. C’est pourquoi l’API fetch a été créée, l’API fetch est en quelque sorte un remplacement moderne pour XMLHttpRequest. Jetons un coup d’oeil à cette méthode window.fetch." />
<meta property="og:description" content="L’API XHR la plus populaire est XMLHttpRequest qui n’a pas vraiment été faite pour ce pour quoi nous l’utilisons. C’est pourquoi l’API fetch a été créée, l’API fetch est en quelque sorte un remplacement moderne pour XMLHttpRequest. Jetons un coup d’oeil à cette méthode window.fetch." />
<link rel="canonical" href="https://blog.alexandrecipor.com//fr/fetch-api" />
<meta property="og:url" content="https://blog.alexandrecipor.com//fr/fetch-api" />
<meta property="og:site_name" content="Alexandre’s Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-10T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Cesser d’utiliser XMLHttpRequest et passer à fetch" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Alexandre CIPOR","url":"https://alexandrecipor.com/"},"dateModified":"2018-08-10T00:00:00+02:00","datePublished":"2018-08-10T00:00:00+02:00","description":"L’API XHR la plus populaire est XMLHttpRequest qui n’a pas vraiment été faite pour ce pour quoi nous l’utilisons. C’est pourquoi l’API fetch a été créée, l’API fetch est en quelque sorte un remplacement moderne pour XMLHttpRequest. Jetons un coup d’oeil à cette méthode window.fetch.","headline":"Cesser d’utiliser XMLHttpRequest et passer à fetch","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.alexandrecipor.com//fr/fetch-api"},"url":"https://blog.alexandrecipor.com//fr/fetch-api"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png" />
    <link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png" />
    <link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png" />
    <link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png" />
    <link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png" />
    <link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png" />
    <link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon-180x180.png" />
    <script defer type="text/javascript" src="/assets/js/app-fr.js"></script>
    <link rel="stylesheet" href="/assets/css/postjs.css" />
</head>

<body>
    <main>
        <article>
            <h1>Cesser d'utiliser XMLHttpRequest et passer à fetch</h1>
            <nav>
                <a href="/fr">
                    <i class="fa fa-chevron-left" style="font-size: 0.7em"></i>
                    Retournez à l'accueil</a>
            </nav>
            <div>
                <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#compatibilité-des-navigateurs">Compatibilité des navigateurs</a></li>
<li class="toc-entry toc-h2"><a href="#utilisation-de-base-de-xmlhttprequest">Utilisation de base de XMLHttpRequest</a></li>
<li class="toc-entry toc-h2"><a href="#utilisation-de-base-de-fetch">Utilisation de base de fetch</a></li>
<li class="toc-entry toc-h2"><a href="#en-têtes-de-requête">En-têtes de requête</a></li>
<li class="toc-entry toc-h2"><a href="#requête">Requête</a></li>
<li class="toc-entry toc-h2"><a href="#réponse">Réponse</a></li>
<li class="toc-entry toc-h2"><a href="#manipulation-du-json">Manipulation du JSON</a></li>
<li class="toc-entry toc-h2"><a href="#manipulation-des-réponses-texthtml">Manipulation des réponses Text/HTML</a></li>
<li class="toc-entry toc-h2"><a href="#manipulation-des-réponses-blob">Manipulation des réponses Blob</a></li>
<li class="toc-entry toc-h2"><a href="#envoyer-des-données-de-formulaire">Envoyer des données de formulaire</a></li>
<li class="toc-entry toc-h2"><a href="#polyfill">Polyfill</a></li>
</ul><p>L’API XHR la plus populaire est <code>XMLHttpRequest</code> qui n’a pas vraiment été faite pour ce pour quoi nous l’utilisons. C’est pourquoi l’API <code>fetch</code> a été créée, l’API <code>fetch</code> est en quelque sorte un remplacement moderne pour <code>XMLHttpRequest</code>. Jetons un coup d’oeil à cette méthode <code>window.fetch</code>.</p>

<h2 id="compatibilité-des-navigateurs">
<a class="anchor" href="#compatibilit%C3%A9-des-navigateurs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Compatibilité des navigateurs</h2>

<p>Une chose importante lors du développement d’une application web est la compatibilité du navigateur avec les technologies utilisées. Comme <code>XMLHttpRequest</code> est plus ancien, il a logiquement une meilleure compatibilité avec les navigateurs plus anciens par rapport à <code>fetch</code>, cependant, il y a des polyfill’s bien faits qui rendent cette API moderne compatible avec les navigateurs plus anciens tels que IE, etc…</p>

<p>(c.f <a href="https://caniuse.com/#search=XMLHttpRequest">Compatibilité XMLHttpRequest</a>, <a href="https://caniuse.com/#search=Fetch">Compatibilité Fetch</a>)</p>

<h2 id="utilisation-de-base-de-xmlhttprequest">
<a class="anchor" href="#utilisation-de-base-de-xmlhttprequest" aria-hidden="true"><span class="octicon octicon-link"></span></a>Utilisation de base de <code>XMLHttpRequest</code>
</h2>

<p>XHR est un peu trop compliqué à mon avis et je ne comprends toujours pas pourquoi <code>XML</code> est en majuscules alors que <code>Http</code> est en camel-case, cela n’a aucun sens. Quoi qu’il en soit, voici un usage courant de l’API XHR</p>

<pre><code class="javascript">if (window.XMLHttpRequest) { // Mozilla, Safari, etc...
    request = new XMLHttpRequest();
} else if (window.ActiveXObject) { // IE
    try {
        request = new ActiveXObject('Msxml2.XMLHTTP');
    } 
    catch (e) {
        try {
            request = new ActiveXObject('Microsoft.XMLHTTP');
        } 
        catch (e) {}
    }
}

// Ouvre la demande et l'envoie
request.open('GET', 'https://exemple.com/api', true);
request.send(null);
</code></pre>

<p>Bien sûr, les frameworks JavaScript rendent l’API XHR plus agréable à utiliser, mais ce que vous voyez ci-dessus est un exemple “<strong>simple</strong>” de l’utilisation la plus basique de XHR. XHR est un vrai gâchis.</p>

<h2 id="utilisation-de-base-de-fetch">
<a class="anchor" href="#utilisation-de-base-de-fetch" aria-hidden="true"><span class="octicon octicon-link"></span></a>Utilisation de base de <code>fetch</code>
</h2>

<p>L’API <code>fetch</code> est fournie dans l’objet <code>window</code> globale, le premier argument étant l’URL (obligatoire) et le second les options (facultatif).</p>

<pre><code class="javascript">// fetch(url, options) | url: obligatoire - options: facultatif
fetch('https://exemple.com/api', {
    method: 'get'
}).then(function(response) {
    // Succès :)
}).catch(function(err) {
    // Erreur :(
});
</code></pre>

<p>Et comme vous pouvez le voir, <code>fetch</code> utilise les promesses Javascript pour gérer les résultats et les callbacks. Si vous n’êtes pas encore habitué aux promesses Javascript, habituez-vous - elles seront bientôt partout.</p>

<h2 id="en-têtes-de-requête">
<a class="anchor" href="#en-t%C3%AAtes-de-requ%C3%AAte" aria-hidden="true"><span class="octicon octicon-link"></span></a>En-têtes de requête</h2>

<p>La possibilité de définir des en-têtes de requête est importante dans la flexibilité de la requête, vous pouvez travailler avec les en-têtes de requête en exécutant <code>new Headers()</code></p>

<pre><code class="javascript">// Créer une instance d'en-têtes vide
const headers = new Headers();

// Ajouter des en-têtes
headers.append('EnTeteCustom', 'MaSuperValeur');
headers.append('Content-Type', 'text/html');

// Vérifier si cet en-tête est présent
headers.has('Content-Type'); // vrai
headers.has('Some-Header'); // faux

// Obtenir la valeur d'un en-tête spécifique
headers.get('EnTeteCustom'); // MaSuperValeur

// Définir une nouvelle valeur pour un en-tête existant
headers.set('Content-Type', 'text/plain');

// Supprimer une en-tête
headers.delete('EnTeteCustom');

// Additionner les valeurs initiales
const headers = new Headers({
    'Content-Type': 'application/json',
    'User-Agent': 'MonSuperUserAgent'
});
</code></pre>

<p>Pour utiliser les en-têtes de Request, vous devez d’abord créer une nouvelle instance de <code>Request</code></p>

<pre><code class="javascript">const request = new Request('https://exemple.com/api', {
    headers: new Headers({
        'Content-Type': 'application/json',
        'User-Agent': 'MonSuperUserAgent'
    })
});

fetch(request).then(function(response) {
    // traiter la réponse
}).catch(function(error) {
    // traiter l'erreur
});
</code></pre>

<h2 id="requête">
<a class="anchor" href="#requ%C3%AAte" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requête</h2>

<p>Une instance de <code>Request</code> représente l’élément de requête d’un appel de la méthode <code>fetch</code>. En passant une <code>Request</code> à l’API fetch, vous pouvez faire des demandes avancées et personnalisées:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">method</code> - <strong>GET</strong>, <strong>HEAD</strong>, <strong>POST</strong>, <strong>PUT</strong>, <strong>DELETE</strong>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">url</code> - <strong>URL</strong> de la requête</li>
  <li>
<code class="language-plaintext highlighter-rouge">headers</code> - objet <strong>Headers</strong> associé</li>
  <li>
<code class="language-plaintext highlighter-rouge">referrer</code> - référant de la requête</li>
  <li>
<code class="language-plaintext highlighter-rouge">mode</code> - <strong>cors</strong>, <strong>no-cors</strong>, <strong>same-origin</strong>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">credentials</code> - les cookies doivent-ils accompagner la demande ? <strong>omit</strong>, <strong>same-origin</strong>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">redirect</code> - <strong>follow</strong>, <strong>error</strong>, <strong>manual</strong>
</li>
  <li>
<code class="language-plaintext highlighter-rouge">integrity</code> - valeur d’intégrité des sous-ressources</li>
  <li>
<code class="language-plaintext highlighter-rouge">cache</code> - mode du cache (<strong>default</strong>, <strong>reload</strong>, <strong>no-cache</strong>)</li>
</ul>

<p>Voici un exemple d’utilisation de <code>Request</code></p>

<pre><code class="javascript">// Construire la requête
const request = new Request('https://exemple.com/anything', {
    method: 'HEAD', 
    mode: 'no-cors', 
    redirect: 'follow',
    headers: new Headers({
        'Content-Type': 'text/html'
    })
});

// Et maintenant, utilisez la requête
fetch(request).then(function() {
    // handle response 
});
</code></pre>

<p>Seul le premier paramètre, l’URL, est requis. Chaque propriété ne peut être que lu dès que l’instance de la <code>Request</code> a été créée. Il est également important de noter que <code>Request</code> a une méthode de clonage qui est importante lors de l’utilisation de <code>fetch</code> dans l’API Service Worker - une <code>Request</code> est un flux et doit donc être clonée lors du passage à un autre appel de <code>fetch</code>.</p>

<pre><code class="javascript">fetch('https://exemple.com/anything', {
    method: 'HEAD', 
    mode: 'no-cors', 
    redirect: 'follow',
    headers: new Headers({
        'Content-Type': 'text/html'
    })
}).then(function() {
    // gérer la réponse 
});
</code></pre>

<p>Vous n’utiliserez probablement que des instances de Request au sein de Service Workers puisque les signatures Request et fetch peuvent être les mêmes.</p>

<h2 id="réponse">
<a class="anchor" href="#r%C3%A9ponse" aria-hidden="true"><span class="octicon octicon-link"></span></a>Réponse</h2>

<p>La méthode then de fetch est une instance de réponse mais vous pouvez également créer manuellement des objets de réponse vous-même – une autre situation que vous pouvez rencontrer lorsque vous utilisez des service workers. Avec une réponse, vous pouvez configurer:</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">type</code> - <strong>basic</strong>, <strong>cors</strong>
</li>
  <li><code class="language-plaintext highlighter-rouge">url</code></li>
  <li>
<code class="language-plaintext highlighter-rouge">useFinalURL</code> - Booléen pour si <strong>url</strong> est l’URL finale.</li>
  <li>
<code class="language-plaintext highlighter-rouge">status</code> - code de statut (ex: <strong>200</strong>, <strong>404</strong>, etc.)</li>
  <li>
<code class="language-plaintext highlighter-rouge">ok</code> - Booléen pour une réponse réussie (statut dans la plage 200-299)</li>
  <li>
<code class="language-plaintext highlighter-rouge">statusText</code> - code de statut (ex: <strong>OK</strong>)</li>
  <li>
<code class="language-plaintext highlighter-rouge">headers</code> - Objet d’en-tête associé à la réponse.</li>
</ul>

<pre><code>// Fausse réponse pour les tests des service workers -- new Response(body, options)
const response = new Response('response body', {
    ok: false,
    status: 404,
    url: '/'
});

// Le then de fetch récupère alors une instance de réponse.
fetch('https://exemple.com/').then(function(response) {
    console.log('ok: ', response.ok); // faux
});</code></pre>

<p>La <code>Response</code> fournit également les méthodes suivantes :</p>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">clone()</code> Crée un clone d’un objet Response</li>
  <li>
<code class="language-plaintext highlighter-rouge">error()</code> Retourne un nouvel objet Response associé à une erreur réseau</li>
  <li>
<code class="language-plaintext highlighter-rouge">redirect()</code> Crée une nouvelle réponse avec une URL différente</li>
  <li>
<code class="language-plaintext highlighter-rouge">arrayBuffer()</code> Retourne une promesse qui se résout avec un ArrayBuffer</li>
  <li>
<code class="language-plaintext highlighter-rouge">blob()</code> Retourne une promesse qui se résout avec un Blob</li>
  <li>
<code class="language-plaintext highlighter-rouge">formData()</code> Retourne une promesse qui se résout avec un objet FormData</li>
  <li>
<code class="language-plaintext highlighter-rouge">json()</code> Retourne une promesse qui se résout avec un objet JSON</li>
  <li>
<code class="language-plaintext highlighter-rouge">text()</code> Retourne une promesse qui se résout avec une USVString (texte)</li>
</ul>

<h2 id="manipulation-du-json">
<a class="anchor" href="#manipulation-du-json" aria-hidden="true"><span class="octicon octicon-link"></span></a>Manipulation du JSON</h2>

<p>Disons que vous faites une requête pour JSON, les données de rappel
résultantes ont une méthode json pour convertir les données brutes
en objet JavaScript</p>

<pre><code class="javascript">fetch('https://exemple.com/api/list.json').then(function(response) { 
    // Convertir en JSON
    return response.json();
}).then(function(jsObj) {
    // jsObj est un objet javascript de la réponse json
    console.log(jsObj); 
});
</code></pre>

<p>La méthode <code>json()</code> est un simple raccourci vers <code>JSON.parse(jsonString)</code></p>

<h2 id="manipulation-des-réponses-texthtml">
<a class="anchor" href="#manipulation-des-r%C3%A9ponses-texthtml" aria-hidden="true"><span class="octicon octicon-link"></span></a>Manipulation des réponses Text/HTML</h2>

<p>JSON n’est pas toujours le format de réponse désiré, alors voici comment vous pouvez travailler avec une réponse HTML ou textuelle</p>

<pre><code class="javascript">fetch('/404').then(function(response) {
    return response.text();
}).then(function(htmlresponse) { 
    // &lt;!DOCTYPE ....
    console.log(htmlresponse); 
});
</code></pre>

<p>Vous pouvez obtenir le texte de réponse enchaînant la méthode <code>then</code> de la promesse avec la méthode <code>text()</code></p>

<h2 id="manipulation-des-réponses-blob">
<a class="anchor" href="#manipulation-des-r%C3%A9ponses-blob" aria-hidden="true"><span class="octicon octicon-link"></span></a>Manipulation des réponses Blob</h2>

<p>Par exemple, charger une image via fetch est un peu différent</p>

<pre><code class="javascript">fetch('https://exemple.com/someimage.jpg').then(function(response) {
    return response.blob();
})
.then(function(imageBlob) {
    document.querySelector('img').src = URL.createObjectURL(imageBlob);
});
</code></pre>

<p>La méthode <code>blob()</code> du Body mixing prend un flux de réponse et le lit jusqu’à la fin.</p>

<h2 id="envoyer-des-données-de-formulaire">
<a class="anchor" href="#envoyer-des-donn%C3%A9es-de-formulaire" aria-hidden="true"><span class="octicon octicon-link"></span></a>Envoyer des données de formulaire</h2>

<p>AJAX est beaucoup utilisé pour envoyer des données de formulaire, voici comment vous le feriez avec l’utilisation de fetch</p>

<pre><code class="javascript">fetch('https://exemple.com/submit', {
    method: 'post',
    body: new FormData(document.getElementById('myForm'))
});
</code></pre>

<p>Et si vous voulez poster des données JSON</p>

<pre><code class="javascript">fetch('https://exemple.com/submit', {
    method: 'post',
    body: JSON.stringify({
        some: document.querySelector('#some').value,
        json: document.querySelector('#json').value,
        data: document.querySelector('#data').value
    })
});
</code></pre>

<p>C’est aussi simple que ça !</p>

<h2 id="polyfill">
<a class="anchor" href="#polyfill" aria-hidden="true"><span class="octicon octicon-link"></span></a>Polyfill</h2>

<p>Il y a beaucoup de Polyfill pour la méthode fetch, mais je vous suggère fortement de vous pencher sur celle de <a href="https://github.com/github/fetch">GitHub</a>.</p>

            </div>
        </article>
    </main>
    <footer>
        <div style="text-align: center">
            <p id="loadtime"></p>
            <p>
                <!-- s'abonner <a href="/fr/feed.xml">via RSS</a> - -->
                <a href="/en" id="r">EN Version</a>
            </p>
        </div>
    </footer>
</body>

</html>